package com.qichen.code2;

/**
 * 虚拟方法调用(Virtual Method Invocation)
 * @author qichen
 * @date 2019/10/27
 * @since JDK1.8
 */
/*
     虚拟方法调用(多态情况下)
        子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父
        类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法
        确定的。
            Person e = new Student();
            e.getInfo(); //调用Student类的getInfo()方法
     编译时类型和运行时类型
        编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类
        的getInfo()方法。 ——动态绑定
 */

/*
方法的重载与重写
    1. 二者的定义细节： 略
    2. 从编译和运行的角度看：
        重载，是指允许存在多个同名方法，而这些方法的参数不同。 编译器根据方法不
        同的参数表， 对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了
        不同的方法。 它们的调用地址在编译期就绑定了。 Java的重载是可以包括父类
        和子类的，即子类可以重载父类的同名不同参数的方法。
        所以： 对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，
        这称为“早绑定”或“静态绑定” ；
        而对于多态，只有等到方法调用的那一刻， 解释运行器才会确定所要调用的具体
        方法，这称为“晚绑定”或“动态绑定” 。
    引用一句Bruce Eckel的话： “不要犯傻，如果它不是晚绑定， 它就不是多态。”
 */
public class VirtualMethodInvocation {
}
